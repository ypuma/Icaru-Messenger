<!DOCTYPE html>
<html>
<head>
    <title>SecMes Storage Test</title>
</head>
<body>
    <h1>SecMes Storage Test</h1>
    <div id="output"></div>
    <button onclick="testStorage()">Test Storage</button>
    <button onclick="clearStorage()">Clear Storage</button>

    <script>
        function log(message) {
            const output = document.getElementById('output');
            output.innerHTML += '<div>' + message + '</div>';
            console.log(message);
        }

        async function testStorage() {
            log('üß™ Testing Storage...');
            document.getElementById('output').innerHTML = '';

            try {
                // Test IndexedDB availability
                if (!window.indexedDB) {
                    log('‚ùå IndexedDB not available');
                    return;
                }
                log('‚úÖ IndexedDB available');

                // Test Web Crypto API
                if (!window.crypto || !window.crypto.subtle) {
                    log('‚ùå Web Crypto API not available');
                    return;
                }
                log('‚úÖ Web Crypto API available');

                // Test salt generation
                const salt = crypto.getRandomValues(new Uint8Array(32));
                log('‚úÖ Salt generation works');

                // Test key derivation
                const password = 'test recovery phrase here';
                const encoder = new TextEncoder();
                const passwordBytes = encoder.encode(password);
                
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    passwordBytes,
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits']
                );
                log('‚úÖ Key material import works');

                const derivedKey = await crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    256
                );
                log('‚úÖ Key derivation works');

                // Test IndexedDB opening
                const dbRequest = indexedDB.open('TestSecMesStorage', 1);
                
                dbRequest.onupgradeneeded = () => {
                    const db = dbRequest.result;
                    if (!db.objectStoreNames.contains('accounts')) {
                        const store = db.createObjectStore('accounts', { keyPath: 'handle' });
                        store.createIndex('timestamp', 'timestamp', { unique: false });
                    }
                };

                const db = await new Promise((resolve, reject) => {
                    dbRequest.onsuccess = () => resolve(dbRequest.result);
                    dbRequest.onerror = () => reject(dbRequest.error);
                });
                log('‚úÖ IndexedDB opening works');

                // Test data encryption
                const testData = JSON.stringify({
                    handle: 'TEST-123',
                    publicKey: 'test-key',
                    createdAt: new Date().toISOString()
                });

                const dataBytes = encoder.encode(testData);
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    new Uint8Array(derivedKey),
                    { name: 'AES-GCM' },
                    false,
                    ['encrypt', 'decrypt']
                );

                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    cryptoKey,
                    dataBytes
                );
                log('‚úÖ Data encryption works');

                // Test data storage
                const transaction = db.transaction(['accounts'], 'readwrite');
                const store = transaction.objectStore('accounts');
                
                await new Promise((resolve, reject) => {
                    const request = store.put({
                        handle: 'TEST-123',
                        data: {
                            ciphertext: Array.from(new Uint8Array(encrypted)).map(b => b.toString(16).padStart(2, '0')).join(''),
                            iv: Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join('')
                        },
                        timestamp: Date.now()
                    });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
                log('‚úÖ Data storage works');

                // Test data retrieval
                const readTransaction = db.transaction(['accounts'], 'readonly');
                const readStore = readTransaction.objectStore('accounts');
                
                const result = await new Promise((resolve, reject) => {
                    const request = readStore.get('TEST-123');
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
                
                if (!result) {
                    log('‚ùå Data retrieval failed - no result');
                    return;
                }
                log('‚úÖ Data retrieval works');

                // Test decryption
                const ciphertext = new Uint8Array(
                    result.data.ciphertext.match(/.{2}/g).map(byte => parseInt(byte, 16))
                );
                const retrievedIv = new Uint8Array(
                    result.data.iv.match(/.{2}/g).map(byte => parseInt(byte, 16))
                );

                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: retrievedIv },
                    cryptoKey,
                    ciphertext
                );

                const decoder = new TextDecoder();
                const decryptedData = decoder.decode(decrypted);
                const parsed = JSON.parse(decryptedData);
                
                if (parsed.handle === 'TEST-123') {
                    log('‚úÖ Data decryption works');
                } else {
                    log('‚ùå Data decryption failed - wrong data');
                    return;
                }

                db.close();
                log('üéâ All storage tests passed!');

            } catch (error) {
                log('‚ùå Storage test failed: ' + error.message);
                console.error('Storage test error:', error);
            }
        }

        async function clearStorage() {
            try {
                // Clear localStorage
                localStorage.clear();
                
                // Clear IndexedDB
                const databases = ['SecMesStorage', 'TestSecMesStorage'];
                for (const dbName of databases) {
                    const deleteRequest = indexedDB.deleteDatabase(dbName);
                    await new Promise((resolve) => {
                        deleteRequest.onsuccess = () => resolve();
                        deleteRequest.onerror = () => resolve(); // Continue even if fails
                    });
                }
                
                log('‚úÖ Storage cleared');
            } catch (error) {
                log('‚ùå Clear storage failed: ' + error.message);
            }
        }
    </script>
</body>
</html> 